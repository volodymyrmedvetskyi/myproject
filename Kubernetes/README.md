Налаштування кластеру було описано у минулому ДЗ, на цей раз також налаштовуємо кластер за допомогою скрипта
1. Було створено app-deployment.yml файл (додано у поточній теці) та одразу у файлі описали service типу NodePort для визначення портів нашого застосунку (80 внутрішній порт, 80 порт контейнера та 30000 зовнішній порт). У якості image для застосунку було обрано image з власного docker репозиторію, який було створено на минулих завданнях. Кількість реплік - 3, відкриваємо порт на контейнері 80.
2. Створили окремо mysql-secrets.yml файл (додано у поточній теці) з паролями до бази даних. Паролі було зашифровано за допомогою сайту https://www.base64encode.org/
3. Створили файл mysql-deployment.yml файл (додано у поточній теці) та одразу у файлі описали service типу NodePort для визначення портів для бази даних (3306 внутрішній порт, 3306 порт контейнера та 30001 зовнішній порт). Використовуємо раніше створені secrets у якості облікових даних до бази.
4. Перевірили коректність роботи кластера, запущено 3 з 3 нод. Запустили secrets та 2 deployments з раніше створених файлів. Скріншот нижче:
![9](https://github.com/volodymyrmedvetskyi/myproject/assets/105160206/f6f9fb7e-bda7-45c8-9bda-ec3457bc7506)
5. Коректність роботи застосунку: командою kubectl describe pods перевірили, на яких нодах запущені поди (2 поди запущені на першому воркері і 1 на другому, тому коректність роботи можемо перевірити з обох публічних IP адрес віртуальних машин з браузера). Скріншот нижче:
![10](https://github.com/volodymyrmedvetskyi/myproject/assets/105160206/aadb1489-bea1-4527-8d71-c5f5491ce328)
6. Коректність роботи бази даних: перевірили через клієнт DBeaver (так як вказали одну репліку бази даних, тому вона запущена лише на першому воркері, але вдалось успішно під'єднатись до бази). Скріншот нижче:
![11](https://github.com/volodymyrmedvetskyi/myproject/assets/105160206/bac819a2-2310-4786-9b7f-df581bc5f9e8)

